# 对象引用、可变性和垃圾回收

变量最好把它们理解为附加在对象上的标注

每个变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理解为对象在内存中的地址。is 运算符比较两个对象的标识；id()函数返回对象标识的整数表。

对象 ID的真正意义在不同的实现中有所不同。在CPython中，id() 返回对象的内存地址，但是在其他Python解释器中可能是别的值。关键是，ID 一定是唯一的数值标注，而且在对象的生命周期中绝不会变。这也是为什么自行创建的类的hash值可用 hash(id)。

## ==和is
`==` 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识。

`is` 运算符比 `==` 速度快，因为它不能重载，所以 Python 不用寻找并调用特殊方法，而是直接比较两个整数 ID。而`a == b`是语法糖，等同于`a.__eq__(b)`。继承自 object的 `__eq__`方法比较两个对象的ID，结果与 is一样。但是多数内置类型使用更有意义的方式覆盖了`__eq__` 方法，会考虑对象属性的值。相等性测试可能涉及大量处理工作，例如，比较大型集合或嵌套层级深的结构时。

## 元组的相对不变性
如果引用的元素是可变的，即便元组本身不可变，元素依然可变。也就是说，元组的不可变性其实是指 tuple 数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。

所以，元组虽然是不可变的，但是它是否可散列还要取决于内部引用的元素是否可变，只有当元素都不可变时，元组才是可散列的。
```python
a = dict()

a[(1,2)] = 3 # (1,2) 可散列
# a[(1,[1])] = 3 # 报错。因为(1,[1]]) 不可散列
```


## 默认做浅复制
看下面这个例子：
```python
a = [1,2,3,[4,5]]
b = list(a)

a is b # F
a == b # T
a[3] is b[3] # T
```
list(l1) 创建 l1 的副本。这是一种浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用）。如果所有元素都是不可变的，那么这样没有问题，还能节省内存。但是，如果有可变的元素，可能就会导致意想不到的问题。上例中 a b 中的子列表是同一对象，修改其中一个会影响另一个。

再看如下的例子：
```python
a = [1,[2,3,4],(5,6,7)]
b = list(a)
a.append(100)
a[1].remove(3)
print('a', a)
print('b', b)
b[1] += [55,66]
b[2] += (88,99)
print('a', a)
print('b', b)
```

输出如下：
```
a [1, [2, 4], (5, 6, 7), 100]
b [1, [2, 4], (5, 6, 7)]
a [1, [2, 4, 55, 66], (5, 6, 7), 100]
b [1, [2, 4, 55, 66], (5, 6, 7, 88, 99)]
```

b[2] 的修改并没有影响到 a[2] 的原因是元组是不可变类型，增量赋值会创建新的对象。

浅复制容易操作，但是得到的结果可能并不是你想要的。

## 深复制
通过 `copy.deepcopy` 可以实现对象的深复制（迭代创建新的对象），copy.copy` 可以实现对象的浅复制

## 函数的参数作为引用时
Python 唯一支持的参数传递模式是共享传参（call by sharing）。共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。，函数可能会修改作为参数传入的可变对象，但是无法修改那些对象的标识（即不能把一个对象替换成另一个对象）。

看下面这个例子：
```python
def func(a, b):
    a += b
    return a

# 第一组
a = 1
b = 2
func(a, b) # 3
a, b # 1, 2

# 第二组
a = [1,2]
b = [3,4]
func(a, b) # [1, 2, 3 ,4]
a, b # [1,2,3,4], [3,4]

# 第三组
a = (1,2)
b = (3,4)
func(a, b) # (1,2,3,4)
a,b # (1,2), (3,4)
```

* 对于第一组，对a重新赋值仅仅只是更改局部变量的引用，外部 a的引用内容不变
* 对于第二组，对列表进行增量复制，局部变量 a 所指向的对象发生改变，和外部a所指向的对象相同
* 对于第三组，对元组增量赋值，因为元组为不可变类型，所以增量赋值会重新创建对象，此时和外部a所指向的对象不同
